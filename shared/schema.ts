import { sql } from "drizzle-orm";
import { pgTable, text, varchar, serial, integer, timestamp, real, boolean, json, unique } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Trends discovered by AI
export const trends = pgTable("trends", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  category: text("category").notNull(),
  platform: text("platform").notNull(), // "tiktok", "youtube", "instagram"
  hotness: text("hotness").notNull(), // "hot", "rising", "relevant"
  engagement: integer("engagement").notNull(),
  hashtags: text("hashtags").array().notNull(),
  sound: text("sound"),
  suggestion: text("suggestion").notNull(), // AI suggestion for using this trend
  timeAgo: text("time_ago").notNull(),
  thumbnailUrl: text("thumbnail_url"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// User-trend interactions (saves, likes, etc.)
export const userTrends = pgTable("user_trends", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  trendId: integer("trend_id").references(() => trends.id, { onDelete: "cascade" }).notNull(),
  action: text("action").notNull(), // "saved", "liked", "used"
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => ({
  userTrendActionUnique: unique().on(table.userId, table.trendId, table.action),
}));

// User's content they want to analyze/optimize
export const userContent = pgTable("user_content", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  derivedFromTrendId: integer("derived_from_trend_id").references(() => trends.id),
  title: text("title"),
  description: text("description"),
  thumbnailUrl: text("thumbnail_url"),
  videoUrl: text("video_url"),
  platform: text("platform").notNull(), // target platform
  status: text("status").notNull().default("draft"), // "draft", "analyzing", "ready", "published"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Analysis results from Launch Pad
export const contentAnalysis = pgTable("content_analysis", {
  id: serial("id").primaryKey(),
  contentId: integer("content_id").references(() => userContent.id, { onDelete: "cascade" }).notNull(),
  clickabilityScore: real("clickability_score").notNull(),
  clarityScore: real("clarity_score").notNull(),
  intrigueScore: real("intrigue_score").notNull(),
  emotionScore: real("emotion_score").notNull(),
  feedback: json("feedback").$type<{
    thumbnail: string;
    title: string;
    overall: string;
  }>().notNull(),
  suggestions: text("suggestions").array().notNull(),
  roastMode: boolean("roast_mode").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Video clips generated by Multiplier
export const videoClips = pgTable("video_clips", {
  id: serial("id").primaryKey(),
  contentId: integer("content_id").references(() => userContent.id, { onDelete: "cascade" }).notNull(),
  title: text("title").notNull(),
  description: text("description"),
  startTime: real("start_time").notNull(), // seconds
  endTime: real("end_time").notNull(), // seconds
  clipUrl: text("clip_url"),
  thumbnailUrl: text("thumbnail_url"),
  viralScore: real("viral_score"),
  status: text("status").notNull().default("processing"), // "processing", "ready", "published"
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// User analytics and performance data
export const userAnalytics = pgTable("user_analytics", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  contentId: integer("content_id").references(() => userContent.id, { onDelete: "cascade" }),
  platform: text("platform").notNull(),
  views: integer("views").default(0).notNull(),
  likes: integer("likes").default(0).notNull(),
  shares: integer("shares").default(0).notNull(),
  comments: integer("comments").default(0).notNull(),
  clickRate: real("click_rate"), // percentage
  recordedAt: timestamp("recorded_at").defaultNow().notNull(),
});

// Background job processing for async tasks
export const processingJobs = pgTable("processing_jobs", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  targetType: text("target_type").notNull(), // "content_analysis", "video_clip", "trend_discovery"
  targetId: integer("target_id"), // ID of the target record
  jobType: text("job_type").notNull(), // "analyze_content", "generate_clips", "find_trends"
  status: text("status").notNull().default("pending"), // "pending", "processing", "completed", "failed"
  progress: integer("progress").default(0).notNull(), // 0-100
  error: text("error"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Activity log for dashboard
export const userActivity = pgTable("user_activity", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  activityType: text("activity_type").notNull(), // "video", "trend", "optimization", "clip"
  title: text("title").notNull(),
  status: text("status").notNull(),
  contentId: integer("content_id").references(() => userContent.id, { onDelete: "cascade" }),
  trendId: integer("trend_id").references(() => trends.id),
  metadata: json("metadata").$type<{
    views?: string;
    engagement?: string;
    score?: string;
    clips?: string;
  }>(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Insert schemas for forms
export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
});

export const insertTrendSchema = createInsertSchema(trends).omit({
  id: true,
  createdAt: true,
});

export const insertUserContentSchema = createInsertSchema(userContent).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertContentAnalysisSchema = createInsertSchema(contentAnalysis).omit({
  id: true,
  createdAt: true,
});

export const insertVideoClipSchema = createInsertSchema(videoClips).omit({
  id: true,
  createdAt: true,
});

export const insertUserAnalyticsSchema = createInsertSchema(userAnalytics).omit({
  id: true,
});

export const insertUserTrendsSchema = createInsertSchema(userTrends).omit({
  id: true,
  createdAt: true,
});

export const insertProcessingJobSchema = createInsertSchema(processingJobs).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertUserActivitySchema = createInsertSchema(userActivity).omit({
  id: true,
  createdAt: true,
});

// Types for TypeScript
export type User = typeof users.$inferSelect;
export type Trend = typeof trends.$inferSelect;
export type UserTrends = typeof userTrends.$inferSelect;
export type UserContent = typeof userContent.$inferSelect;
export type ContentAnalysis = typeof contentAnalysis.$inferSelect;
export type VideoClip = typeof videoClips.$inferSelect;
export type UserAnalytics = typeof userAnalytics.$inferSelect;
export type ProcessingJob = typeof processingJobs.$inferSelect;
export type UserActivity = typeof userActivity.$inferSelect;

export type InsertUser = z.infer<typeof insertUserSchema>;
export type InsertTrend = z.infer<typeof insertTrendSchema>;
export type InsertUserTrends = z.infer<typeof insertUserTrendsSchema>;
export type InsertUserContent = z.infer<typeof insertUserContentSchema>;
export type InsertContentAnalysis = z.infer<typeof insertContentAnalysisSchema>;
export type InsertVideoClip = z.infer<typeof insertVideoClipSchema>;
export type InsertUserAnalytics = z.infer<typeof insertUserAnalyticsSchema>;
export type InsertProcessingJob = z.infer<typeof insertProcessingJobSchema>;
export type InsertUserActivity = z.infer<typeof insertUserActivitySchema>;
